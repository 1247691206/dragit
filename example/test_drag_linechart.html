<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<title>Testing Drag and Drop</title>
<head>
  <link href="css/ds.css" rel="stylesheet">
  <link href="../src/dragit.css" rel="stylesheet"/>  
</head>

<body>

  <script src="../lib/d3.v3.js"></script>
  <script src="../src/dragit.js"></script>

  <style>
/*
    body {
      background: #222;
      background-color: #222; 
    }
*/
    g.state circle {
        stroke  : gray;
        cursor  : pointer;
        fill    : white;
    }

    circle.selected {
      stroke          : red;
      stroke-width: 4px;
    }

    g.state circle.outer {
        stroke-width    : 0px;
        stroke-dasharray: 4px;
        stroke-opacity  : 0.5;
        fill            : transparent;
    }

    g.state text {
        font                : 12px sans-serif;
        font-weight         : bold;
        pointer-events      : none;
    }

    path.transition {
        fill        : none;
        stroke      : #000;
        stroke-width: 1px;
        cursor      : default;
        marker-end  : url(#end-arrow);
    }

  </style>

  <style>

  div.source {
    border-style: solid;
  }

  div.target {
    border-style: dotted;
  }

  </style>

  <div id="state"></div>

  <script>

  /* TODO

    -Use arcs for transitions  
    -See how to include in dragit (especially the target?)
    -Get list of states from dragit and their update too
    -Name the link for transitions
    -Show self-link nodes
    -Set a specific state to define the focus (mouseleave, etc.)
    -Put sates on a grid and add a scale
    -How to illustrate snapping (e.g. automatic return to a position)
    -Show example with dragit dual representation visualization
    -Include in dragit (make it an option?)
    -

  */

  var radius = 35;

  var states = [
      {x: 100, y:200, label:"idle", transitions: [], focus: true},
      {x: 300, y: 200, label:"mouseover", transitions: []},
      {x: 500, y:200, label:"drag table", transitions: []},
      {x: 500, y:400, label:"display line", transitions: []},  
      {x: 700, y:400, label:"drag line", transitions: []}  
  ];

  states.forEach(function(d, i) {
    d.id = i;
  })

  // Idle to mouse over
  states[0].transitions.push({label : 'mouse enter', target : states[1], px: 200, py: 170})

  // Idle to itself
  states[0].transitions.push({label : 'mouse move', target : states[0], px: 100, py: 50})

  // Mouse
  states[1].transitions.push({label : 'mouse move', target : states[1], px: 300, py: 50})

  states[1].transitions.push({label : 'mouse out', target : states[0], px: 200, py: 250})

  states[1].transitions.push({label : 'click press', target : states[2], px: 400, py: 150})

  states[2].transitions.push({label : 'click release', target : states[1], px: 400, py: 250})

//  states[2].transitions.push({label : 'Mouse move', target : states[2], px: 400, py: 250})

  // Drag table to drag line
  states[2].transitions.push({label : 'Mouse move', target : states[3], px: 400, py: 250})
  states[3].transitions.push({label : 'Mouse move', target : states[2], px: 400, py: 250})

  // Drag line chart to drag line
  states[3].transitions.push({label : 'Mouse move', target : states[4], px: 400, py: 250})
  states[4].transitions.push({label : 'Mouse move', target : states[3], px: 400, py: 250})

  states[4].transitions.push({label : 'Mouse move', target : states[4], px: 400, py: 250})

  // http://www.dashingd3js.com/svg-paths-and-d3js
  var computeTransitionPathX = /*d3.svg.diagonal.radial()*/function(d) {
      
      var deltaX = d.target.x - d.source.x,
      deltaY = d.target.y - d.source.y,
      dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
      
      normX = deltaX / dist,
      normY = deltaY / dist,
      
      sourcePadding = radius + 2;//d.left ? 17 : 12,
      targetPadding = radius + 6;//d.right ? 17 : 12,

      sourceX = d.source.x + (sourcePadding * normX),
      sourceY = d.source.y + (sourcePadding * normY),
      targetX = d.target.x - (targetPadding * normX),
      targetY = d.target.y - (targetPadding * normY);

      return 'M' + sourceX + ',' + sourceY + 'S' + d.px + ',' + d.py + "T"  + d.px + ',' + d.py +  " "  + targetX + "," + targetY;

//      return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
  };

  var computeTransitionPath = /*d3.svg.diagonal.radial()*/function(d) {
      
      var x1 = d.source.x,
          y1 = d.source.y,
          x2 = d.target.x,
          y2 = d.target.y,
          dx = x2 - x1,
          dy = y2 - y1,
          dr = Math.sqrt(dx * dx + dy * dy),

          // Defaults for normal edge.
          drx = dr,
          dry = dr,
          xRotation = 0, // degrees
          largeArc = 0, // 1 or 0
          sweep = 1; // 1 or 0

          // Self edge.
          if ( x1 === x2 && y1 === y2 ) {
            // Fiddle with this angle to get loop oriented.
            xRotation = -90;

            // Needs to be 1.
            largeArc = 1;

            // Change sweep to change orientation of loop. 
            //sweep = 0;

            // Make drx and dry different to get an ellipse
            // instead of a circle.
            drx = 50;
            dry = 10;
            
            // For whatever reason the arc collapses to a point if the beginning
            // and ending points of the arc are the same, so kludge it.
            x2 = x2 + 1;
            y2 = y2 + 1;


            var deltaX = x2 - x1,
            deltaY = y2 - y1,
            dist = -10*Math.sqrt(deltaX * deltaX + deltaY * deltaY),
            
            normX = deltaX / dist,
            normY = deltaY / dist,
            
            sourcePadding = radius + 70;//d.left ? 17 : 12,
            targetPadding = radius + 70;//d.right ? 17 : 12,

            x1 = x1 + (sourcePadding * normX),
            y1 = y1 + (sourcePadding * normY) - 25,
            x2 = x2 - (targetPadding * normX),
            y2 = y2 + (targetPadding * normY) - 30;

          } else {

            var deltaX = d.target.x - d.source.x,
            deltaY = d.target.y - d.source.y,
            dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
            
            normX = deltaX / dist,
            normY = deltaY / dist,
            
            sourcePadding = radius + 2;//d.left ? 17 : 12,
            targetPadding = radius + 6;//d.right ? 17 : 12,

            x1 = x1 + (sourcePadding * normX),
            y1 = y1 + (sourcePadding * normY),
            x2 = x2 - (targetPadding * normX),
            y2 = y2 - (targetPadding * normY);

          }

     return "M" + x1 + "," + y1 + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;

  };


  var transitions = function() {
      return states.reduce( function( initial, state) {
          return initial.concat( 
              state.transitions.map( function(transition) {
                  return {source : state, target : transition.target, label: transition.label, px: transition.px, py: transition.py};
              })
          );
      }, []);
  };
  
  // Init the focus and return the current one
  function reset_focus(states) {
    var current_focus = -1;

    states.forEach(function(d, i) {
      if(d.focus == true)
        current_focus = d;
      d.focus = false;
    })

    return current_focus;
  }

  function init() {

  }

  function update() {

    gStates = d3.select("svg")
      .selectAll( "g.state").data(states);
    
    var gState = gStates.enter()
        .append( "g")
        .attr({
            "transform" : function( d) {
                return "translate("+ [d.x,d.y] + ")";
            },
            'class'     : 'state'
        });
    
    gState.append( "circle")
        .attr({r: radius + 4, class: 'outer'})
        .on( "mousedown", function( d) {

            startState = d, endState = undefined;

            // reposition drag line
            drag_line
                .style('marker-end', 'url(#end-arrow)')
                .classed('hidden', false)
                .attr('d', 'M' + d.x + ',' + d.y + 'L' + d.x + ',' + d.y);

            // force element to be an top
            this.parentNode.parentNode.appendChild( this.parentNode);
            console.log( "mousedown", startState);
        });

    gState.append( "circle")
        .attr({
            r       : radius,
            class   : function(d) {
              if(typeof d.focus != "undefined" && d.focus == true)
                return 'selected inner';
              else
                return 'inner';
            }
        });

    d3.selectAll("circle.inner")
              .attr({

            class   : function(d) {
              if(typeof d.focus != "undefined" && d.focus == true)
                return 'selected inner';
              else
                return 'inner';
            }
        });

    gState.append( "text")
        .attr({
            'text-anchor'   : 'middle',
            y               : 4
        })
        .text( function( d) {
            return d.label;
        });

    gState.append( "title")
        .text( function( d) {
            return d.label;
        });

    gStates.exit().remove();

    gTransitions = svg.selectAll("g.transition").data(transitions);

    var gTransitions_enter = gTransitions.enter().append("g").attr("class", "transition");

    gTransitions_enter.selectAll("path").data(function(d) { return [d];}).enter().append("path")
        .attr("class", "transition")
        .attr("id", function(d, i) {
          return "link--"+d.source.id+"--"+d.target.id;
        })
        .attr('d', computeTransitionPath);

    gTransitions_enter.selectAll("text").data(function(d) { return [d];}).enter().append("text")
        .attr('text-anchor', 'middle')
        .attr('x', function(d) { return d.px; })
        .attr('y', function(d) { return d.py; })
        .text(function(d) { return d.label; })

    gTransitions.exit().remove();
  };

function create_state_diagram(el) {

  var margin = {top: 20, right: 20, bottom: 20, left: 20},
      width = 900 - margin.right - margin.left,
      height = 500 - margin.top - margin.bottom;

   svg = d3.select(el)
      .append("svg")
        .attr({width: width, height: height})

  svg.append('svg:defs').append('svg:marker')
      .attr('id', 'end-arrow')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 3)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
    .append('svg:path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#000');

  svg.append('svg:defs').append('svg:marker')
      .attr('id', 'start-arrow')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 4)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
    .append('svg:path')
      .attr('d', 'M10,-5L0,0L10,5')
      .attr('fill', '#000');

  var gStates = svg
      .selectAll("g.state")
      .data(states);

  var gTransitions = svg.append( 'g')  
      .selectAll( "path.transition")
      .data(transitions);


  var dragit_margin = {top: 300, right: 20, bottom: 20, left: 20},
      dragit_width = 400 - dragit_margin.right - dragit_margin.left,
      dragit_height = 200 - dragit_margin.top - dragit_margin.bottom;


var nb_points = 1;

dragit.time = {min: 0, max: 20, step: 1, current: 0};
dragit.time.current = Math.floor(Math.random()*dragit.time.max);

var timecube = d3.range(nb_points).map(function(d, i) {
  return d3.range(dragit.time.max).map(function(e, j) { 
    return {x: j, y: Math.random(), t: j};
  });
})

var xScale = d3.scale.linear().domain([0, dragit.time.max]).range([dragit_margin.left, dragit_width]);
var yScale = d3.scale.linear()
           .domain([0, d3.max(timecube, function(d) { 
              return d3.max(d, function(e) { 
                return e.y; 
              });
            })
           ])
           .range([400, 300]);


var gPoints = svg.selectAll(".points")
                .data(timecube)
              .enter()
                .append("g")
                .on("mouseenter", dragit.trajectory.display)
                .on("mouseleave", dragit.trajectory.remove)
                .call(dragit.object.activate)
                .attr("transform", function(d) {
                  return "translate("+xScale(d[dragit.time.current].x)+", "+yScale(d[dragit.time.current].y)+")";
                })
                .attr("class", "points");

gPoints.append("rect")
      .attr({width: 100, height: 10, fill:"white", stroke: "black"})
   .on("mouseenter", function( d) {

    //  d3.event.stopPropagation();
      var current_node = reset_focus(states);
      show_transition(current_node.id, 1);

      states[1].focus = true;
      update();

    })
    .on("mousemove", function( d) {

   //   d3.event.stopPropagation();

      var current_node = reset_focus(states);
      show_transition(current_node.id, 1);

      states[1].focus = true;
      update();

    })    
    .on("mouseleave", function( d) {  

    //  d3.event.stopPropagation();

      var current_node = reset_focus(states);
      show_transition(current_node.id, 0);

      states[0].focus = true;
      update();

    })

  dragit.evt.register("dragstart", dragstart);
  dragit.evt.register("drag", dragmove);
  dragit.evt.register("dragend", dragend);

function dragit_update(v, t) {

  dragit.time.current = v || dragit.time.current;
  
  gPoints.transition().duration(100)
                .attr("transform", function(d) {
                  return "translate("+xScale(d[dragit.time.current].x)+", "+yScale(d[dragit.time.current].y)+")";
                });
}

function init() {

  dragit.init("svg");

  dragit.data = timecube.map(function(d, i) { 
    return d.map(function(e, i) { 
      return [xScale(e.x), yScale(e.y)]; 
    }) 
  });
  
  dragit.evt.register("update", dragit_update);

  dragit.playback.loop = true;
  dragit.playback.speed =  500;
  dragit.utils.slider("#slider", true);
}

init();



  update();



}

create_state_diagram("#state")

var width = 800,
    height = 600;

var w = 100, h = 30;

var drag = d3.behavior.drag()
    .origin(function(d) { return d; })
    .on("dragstart", dragstart)
    .on("dragend", dragend)
    .on("drag", dragmove);

var data = [
    {x: 0, y: 0, color: "red"}
];

/*
d3.select("body")
    .on("mousemove", function( d) {

      // Add new state to the diagram
      console.log("mousemove body", d)

      var current_node = reset_focus(states);
      show_transition(current_node.id, 0);

      states[0].focus = true;
      update();

    })  
*/

/*
var div = d3.select("body")
    .selectAll("div.source")
    .data(data)
  .enter()
    .append("div")
    .style({
        width: w + "px",
        height: h + "px",
        "background-color": function(d, i){ return d.color },
        position: "absolute",
        left: function(d, i){ return d.x + "px"; },
        top: function(d, i) { return d.y + "px"; }
    })
    .attr("class", "source")
    .on("mouseenter", function( d) {

    //  d3.event.stopPropagation();

      var current_node = reset_focus(states);
      show_transition(current_node.id, 1);

      states[1].focus = true;
      update();

    })
    .on("mousemove", function( d) {

   //   d3.event.stopPropagation();

      var current_node = reset_focus(states);
      show_transition(current_node.id, 1);

      states[1].focus = true;
      update();

    })    
    .on("mouseleave", function( d) {  

    //  d3.event.stopPropagation();

      var current_node = reset_focus(states);
      show_transition(current_node.id, 0);

      states[0].focus = true;
      update();

    })

    .call(drag);
*/
function dragmove(d) {
 
  console.log("dragmove", d3.event.x);

  if(typeof d == "undefined")
    d = {};

/*  d.x = d3.event.x;
  d.y = d3.event.y;
  leftVal = d.x + "px";
  topVal = d.y + "px";
*/
//  d3.event.stopPropagation();

  var current_node = reset_focus(states);
  show_transition(4, 4);

  states[2].focus = true;
  states[3].focus = true;  
  update();
/*
  d3.select(this)
      .style({left: leftVal, top: topVal})
      .html("x: " + d.x + "<br /> y:" + d.y + "<br /> dx:" + d3.event.dx + "<br /> dy: " + d3.event.dy);
*/
}

function dragstart(d) {

  // Add new state to the diagram
  console.log("dragstart", d)

  var current_node = reset_focus(states);
  show_transition(1, 2);
  show_transition(2, 3);

  states[2].focus = true;
  update();

}

function dragend(d) {

  // Add new state to the diagram
  console.log("dragend", d)

  var current_node = reset_focus(states);
  show_transition(4, 3);
  show_transition(3, 2);
  show_transition(2, 1);

  states[1].focus = true;
  update();

}

function show_transition(id_source, id_target) {



  var c = d3.select("svg").append("circle").attr({cx: 0, cy: 0, r: 5}).style({fill: "red"})

  // Retrieve path
  var path = d3.select("#link--"+id_source+"--"+id_target);

  // Animate node
  c.transition()
    .duration(1000)
    .attrTween("transform",  dragit.utils.translateAlong(path, 100))
    .each("end", function(d, i) {
      d3.select(this).remove();
    })

}

  </script>  
</body>
</html>